## Understanding and Defending the Binder Attack Surface In Android

> author: Huan Feng & Kang G. Shin
> date: 2016 ACSAC
> 链接: [Paper](http://dx.doi.org/10.1145/2991079.2991120)

### 摘要
Binder 作为 IPC 机制的基石，将通信双方分割成客户端和服务端。而在C/S 模型中，服务器不应该对客户端事务的有效性进行任意猜测

本文通过对此攻击面的 100 多个漏洞研究，发现大部分漏洞根本成因是系统开发人员没有一个准确的安全边界的认知

BinderCracker ，自动化测试框架，支持上下文敏感模糊测试，可以管理事务之间的依赖关系
不依赖组件源代码，兼容多层服务，比简单黑盒测试性能提高 7 倍

由于操作系统级别支持的缺乏使得即使是拥有 adb 访问的开发者也很难识别恶意应用程序。我们通过构建信息量巨大的运行时诊断工具解决这一问题。

### 简介
问题：为什么系统开发者坚持使用这种看起来如此简单的检查手段，我们可以做什么缓解这种问题？

针对 Binder 攻击面
研究 6 个安卓版本 
Google 98 个一般系统服务
Samsung 72 个特定厂商服务
137 个漏洞

关于安卓系统服务的安全边界的错误概念 —— 很多都认为安全可信边界是在客户端边界公开 API，之后发生的一切因为都属于系统区域所以不进行阻拦

BinderCracker:
- 为基于 Binder 的 RPC 预留的测试框架
- 上下文敏感 —— 理解每个 RPC 事务的输入输出结构以及他们之间的依赖关系
- 测试前会重放所有依赖的事务代码并生成正确的上下文
- 无需需要测试服务的源代码，为 Java 层和 Native 层服务同时工作
- 理解每个低层 RPC 事务的架构，可以很方便的构造并测试高层抽象或协议，比如 Intent 通信，或特定 app 的协议

通过 BinderCraker 发现的 60% 的漏洞仍旧没有修复

informative runtime diagnostic tool:
- sender
- schema
- content
- parsing information

### 相关工作
**软件测试**
健壮性测试分为两类：功能测试、异常测试

功能性测试聚焦于使用预期的输入验证软件的功能性
异常检测尝试使用非预期和错误输入来崩溃系统

**android 安全**
已存在的安卓安全研究大都关注高层权限模型的不完美实现以及导致的问题

很多针对安卓 IPC 机制的研究都关注于一个特殊的 android IPC 实例 —— intent

### 安卓 IPC & BINDER
**Binder**
consists
1. 实现进程间通信的内核驱动
2. Binder 库使用 ioctl 系统调用与内核驱动沟通
3. 利用 Binder 库的上层抽象

Binder 客户端和服务端的沟通顺序允许客户端实现远过程调用，并且在远程服务器上调用方法

**AIDL**
Android Interface Description Language
允许开发者定义客户端和服务端一致同意的 RPC 接口，不用实现底层细节

**System Service**
系统开发者只需要定义 AIDL 描述，并实现相应的服务端逻辑和客户端包装

接口参数的序列化、传输、反序列化都由 AIDL 文件自动生成的代码处理

### BINDER：攻击面
已知的攻击基本是直接通过 Binder 接口注入精心构造的事务代码

理论上，无论事务代码从客户端哪一层注入都不会影响安卓系统的安全性，服务端能始终保持自身的健壮性

**攻击模型**
假设对手是恶意软件开发者，不断尝试妨害安卓系统服务的健壮性或完整性

假设攻击者没有 root 权限，不能渗透操作系统内核的安全性

**漏洞概览**
覆盖超过 2400 个低级 RPC 方法
大部分漏洞存在于安卓框架中，15 个存在于特定供应商服务

测试配置：
- 在初始状态下测试，不安装第三方 app 或改变其他配置
- 仅打开 adb 调试选项，排除外部因素影响

认定 vulnerable 的条件：
经测试，RPC 方法会导致 致命错误、安卓运行时的部分或全部崩溃

每一个报告的漏洞：
1. 在官方 ROM 下识别
2. 手动确认为可重放
3. 检查源代码以进行根本分析

**根本原因分析**
崩溃的直接原因是未捕获异常错误

客户端开放 API 最广泛使用的就是 sanity 检查

很多系统开发者仅仅考虑公开 API 的利用，因此直接向 Binder 驱动注入错误事件，构建许多超出他们想象的情况

一些新的攻击向量：
1. 攻击者可以操纵没有通过公共 API 公开的 RPC 参数
开发者不应忽视私有或隐藏的 RPC 接口

2. 攻击者可以绕过公共 API 的完整性检查，无论多么复杂

3. 攻击者可以利用特定数据类型的序列化进程创建对于服务端有危险的输入

#### 有效的漏洞发现
最直白的方法就是 发送包含任意字节的事务代码 —— 黑盒测试

**独特的挑战**
- Binder 事务可能包含非初级数据类型
48%
事务的参数列表通常是动态的而不是静态的

- Binder 事务间通常存在相关依赖
37% user-level

-- 受到源码是否可利用的限制

**Binderaker：设计概览**
- recording 组件    —— Android 拓展
记录不同 Binder 事务的详细信息
- fuzz 组件         —— user-level app
重放并修改每个被记录的事务

recording 组件通过在事务代码正反序列化进程中插桩获取运行时事务代码的模型（参数类型和结构）
监管并记录每个参数是如何从 Parcel 对象中解组出来的
为了记录事务模型，BinderCracker 自动匹配邻接事务的输入和输出，构建他们之间的依赖结构图，使得可以自动管理依赖关系并重建每个事务所需的动态上下文

fuzz 组件拥有内置重放引擎
操纵要发送给 Binder 驱动的 binder_transaction_data 结构
数据结构包含三个重要部分：
- target.handle ——> 指定目标服务
- code ——> 特定 RPC 方法
- data ——> 参数列表的序列化字节

**事务重定向**
从 handle 变量到系统服务的一对一映射，创建于运行时，由 Binder 驱动维持

由于系统服务是静态缓存的，可以通过查询静态 service manager 间接获取

code 与 RPC method 的映射可以在由 AIDL 文件自动生成的 Stub 文件中找到

native 系统服务不是由 Java 实现，映射是直接编码的，所以我们通过扫描 AIDL 文件和安卓本地源码构建映射关系

**事务模糊测试**
BinderCracker 利用上下文敏感的重放引擎生成半有效性 fuzz 事务代码

![](./截屏2020-11-24%20上午11.31.34.png)

#### 防护防御
**Precautionary 测试**
- before releasing a new ROM
static code analysis tool - lint
- after
during runtime - BinderCracker

**Runtime Diagnostics and Defenses**
潜在的防御手段：
- 入侵监测/预防，识别并弹出恶意事务
- 入侵诊断，使攻击可视化

系统级诊断工具：
- 服务破坏时，记录事务的发送者并通知使用者
- 详细信息将会 dump 到报告中为以后取证做准备
- 生成事务签名，用户可以回顾并选择关闭相同事件的未来出现