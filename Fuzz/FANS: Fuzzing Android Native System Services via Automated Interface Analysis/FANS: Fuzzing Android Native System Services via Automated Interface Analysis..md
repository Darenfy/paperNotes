## FANS: Fuzzing Android Native System Services via Automated Interface Analysis

> 作者：Baozheng Liu and Chao Zhang and Guang Gong and Yishun Zeng and Haifeng Ruan and Jianwei Zhuge
> 出处：USENIX Security 20
> 文章：[paper](https://www.usenix.org/conference/usenixsecurity20/presentation/liu)

### 摘要
安卓原生系统服务给用户应用提供了必要支持和基础功能，在这类系统服务中的漏洞会带来更大的危害

使用流行的 **Fuzz** 技术挖掘漏洞

难点：
1. 这些服务是通过 **binder**（一种特殊的 **IPC** 机制）基于特定服务的接口进行调用的，因此 **fuzzer** 需要自动区分所有的接口并对应生成特定接口的测试用例
2. 有效的测试用例应满足每个接口的接口模型
3. 测试用例也应该满足语义要求，包括变量依赖性和接口依赖性

在本文提出了一种基于自动生成的 **Fuzz** 解决方案 **FANS** 来发掘 安卓原生系统服务中的漏洞
工作流程：
1. 收集目标服务的所有接口并发现深层嵌套的多层接口以进行测试
2. 自动从目标接口的抽象语法树中提取接口模型，包括可行的事务代码、事务数据中的变量名称和类型
3. 通过变量名称和类型知识推断事务中的变量依赖关系，并通过生成和使用关系推断接口依赖关系
4. 使用接口模型和依赖知识生成事务序列（已拥有有效的格式和语义）以测试目标服务的接口


使用 **scratch** 实现 **FANS** 的原型
在装有较新安卓版本的六台手机上进行了评估测试
来自数千次崩溃
30个独特漏洞，其中20个已被Google确认
还发现了138个独特的 Java 异常

### Chapter 1 Introduciton
<!--
安卓占据了超过85%的市场
安卓最基础的功能都来自安卓系统服务
截止2019.10 数百个与安卓系统服务相关的漏洞已经被报给谷歌

这些漏洞中很大一部分都是原生系统服务，即主要都是C++写的

这些漏洞允许 远程攻击
通过使用来自第三方应用程序的精心设计的输入来启动IPC请求来执行特权提升。
-->
两款自动化模糊测试方法
- Binder-Cracker
抓取目标服务的输入模型  通过记录由30款app发出的请求
不能恢复精确的输入语义 比如变量名和变量类型
在不完全的测试中 忽略了很少使用的或深层嵌套的接口
- Chizpurfle
利用 Java 反射去获取接口的参数类型以测试 vendor-implemented Java 服务
并不能获取到 安卓原生系统服务的 输入模型

<!--Android 中
系统服务 -> Register -> Service Manager
用户应用 -> Query -> 目标服务的接口（被封装在代理Binder对象中）-> invoke -> 不同的事务类型（通过IBinder的统一RPC接口）
IBinder::transact(code, data, reply, flags)
code: 决定了要调用的目标事务
事务的输入被整理到序列化的 parcel 对象数据中


使用统一的IPC方法测试所有的系统服务

为了彻底测试系统服务
1.找到所有的接口和可利用事务
2.使用满足特定于服务的格式和语义要求的输入数据来调用它们
-->
三个挑战：
- 多层接口识别
顶层接口 -> Service Manager
嵌套多层接口 -> retrieve via 顶层接口 -> invoke by 用户应用
考虑到很多接口由 AIDL 定义 not C++  且    编译期间动态生成

- 接口模型抽取
获取要测试的受支持事务列表
提供输入data来调用每个事务
提高fuzz的有效性，输入data应该遵循目标接口的语法要求
从安卓源代码中自动抽取十分有挑战
  1. 独立的事务语法是特殊的。必须识别所有可行的事务并抽取他们中的每一个语法
  2. 语法要求 共存于 路径约束  比如 分支状态，循环状态 甚至嵌套循环
<!--
手动提供语法知识不能大规模
-->
- 语义正确的生成输入
安卓提供了 sanity check 对于 输入data
不满足语法要求，无法探索深层状态或触发漏洞
语法要求很多类型：
变量名称 变量类型 变量之间或接口之间的依赖关系
<!--
packageName 
一个名为packageName的变量表示需要一个现有软件包的名称；
枚举类型的变量只能具有一组有限的候选值；
当前事务中的变量可能取决于当前或先前事务中的另一个变量，甚至一个接口也可能取决于另一个接口。
-->
处理方式
- 通过扫描系统注册操作 识别所有的顶层接口 
底层接口都是通过调用特定方法 writeStrongBinder 生成
利用这一点 识别多层接口

- 安卓系统服务一直使用一套特定的反序列化方法 解析输入数据
通过识别这些方法的调用序列 推断有效输入的语法
为了保护变量名称和类型的知识，选择从抽象语法树中抽取反序列化结果（即输入语法）

- 利用得到的变量名称和类型生成恰当的输入并识别内部事务的变量依赖关系
现象：从属事务会反序列化被主事务序列化的数据 -> 识别事务间依赖关系
依靠接口间的生成和使用关系推断他们的依赖关系

open source : https://github.com/iromise/fans

贡献：
1. 系统性的调查安卓原生系统服务中接口的依赖关系并发掘出更深层的多层接口
2. 提出解决方法，从抽象语法树中自动抽取输入接口模型和语义。这个方法可以应用到其他基于接口的程序中
3. 提出解决方法，通过利用不同事务序列化与反序列化对的变量名称和类型的知识推断内部事务的依赖类型
4. 实现了FANS系统性模糊测试安卓原生系统服务，发现了30个vul和138个Java 异常

### Chapter 2 背景
#### Chapter 2.1 安卓系统服务
**安卓系统服务的分类**
根据编程语言的不同，分成两类：
- Java系统服务
主要使用 java 实现，例如 activity manager
- Native 系统服务
主要使用 C++ 实现， 例如 camera services

一些安卓原生系统服务作为守护程序运行，例如 netd。 
原生服务有时可能会调用 Java 代码，反之亦然。

从安卓 8 开始，服务被分成三类：normal，vendor，hardware domain
normal domain -> 直接在AOSP中
vendor & hardware domain -> vendors & hardwares

**应用程序-服务 通讯模型**
workflow of it
![](截屏2020-08-04%20上午10.18.02.png)
1. service -> register -> service manager
2. app -> request -> service manager 
3. service manager -> return -> app
4. app -> request -> service
5. service -> return -> app

binder driver 桥接 应用与服务之间的通信

**安卓系统服务中的接口**
应用通过统一 RPC 接口调用顶层接口的目标事务
因此服务端肯定有负责处理基于事务代码请求的分配器
这个分配器在统一方法 onTransact(code, data, reply, flags)中定义
分配器 -> 反序列化 输入data -> 处理相应客户端的请求

总的来说，每个服务都有一套可以通过 RPC 调用的方法
这些方法在基类中声明
但是分别在客户端代理和服务器端存根中实现。
binder driver 桥接代理和存根对象以进行通信

这个机制也同样应用于多层接口，因为多层接口和顶层接口共享相同的结构
与多层接口相对应的Binder对象在 service manager 中不可用，并且只能通过顶层接口进行检索

不是所有的接口都在C++中静态定义，其中一些在AIDL中被定义
当构建安卓镜像时，将调用AIDL工具动态生成适合的C++语言以进行进一步编译

#### Chapter 2.2 研究范围
聚焦于发现安卓原生系统服务（在service manager中注册 属于normal domain）中的漏洞

### Chapter 3 设计
#### Chapter 3.1 设计选择
**RPC-centric testing**
多种测试安卓原生系统服务的方法，最直接的办法：
不调用统一 binder 通信接口 transact ，直接注入特定服务事件到系统中测试目标事务
但是 向不同进程不同服务注入事件 很大的工程挑战

以这种方式发现的漏洞很可能是虚假的警报，因为实际上对手无法生成任意事件

对手必须通过IPC接口与目标服务进行交互，只能产生有限的事件数
- binder IPC 机制提供一些 sanity check
- 打包到一个包裹中的数据可能取决于某些动态系统状态

**Generation-based fuzzing**
mutation-based -> 通过已有的测试用例变化产生新的测试用例
无效格式和语义的测试用例  ->  不能被目标服务正确反序列化或处理 -> 低代码覆盖率 遗漏潜在漏洞
generation-based -> 根据输入规范生成测试用例

**从代码中学习输入模型**
generation-based fuzzer 依赖于输入模型知识产生行之有效的测试用例

很多GBF 依赖人们生成的语法文件产生测试用例 -> 大量人工 不适用于 Android 服务
其他 GBF 从存在的事务中学习产生新的输入 -> 依赖样例事务的完整性和忽略少用的事务 不完整 只有事务数据 学习的输入模型不正确

自动获取输入模型知识 <- 分析源码 <- 源码(bury 输入模型)

#### Chapter 3.2 Overview of FANS
![](截屏2020-08-04%20上午10.42.18.png)

#### Chapter 3.3 接口收集器
不直接扫描AOSP代码库中的 C/C++ 文件寻找 onTransact 方法

检查在AOSP编译命令中作为源出现的每个 C/C++ 文件，以便收集 AIDL 工具在编译过程中动态生成的接口，
#### Chapter 3.4 接口模型抽取
**抽取原则**
- 完整性：获取接口以及他们事务的完全集 -> 接口收集器
- 精确性：无效随机输入会掉入异常处理，要构建能通过 sanity check 的有效输入  变量模式（formats），变量名称，变量类型（semantically）
- 便利性：采用一种方便的方法来提取接口模型。 最好找到一种统一的方法来处理 C++ 中定义的接口和 AIDL 中定义的接口。

**抽取设计选择**
从服务端代码抽取
client -> RPC interface transact -> Service -> onTransact
从任意一端都能抽取所有可能的事务
- 要测试的是服务，直接处理服务端会让我们更准确的了解服务端代码期望什么样的输入
服务如何使用从数据反序列化的输入以及序列化为回复的输出
- 接口具有多个事务，它们的定义和实现通常紧密地分布在服务器端代码中。客户端代码可能以分散的方式调用它们，给接口模型提取带来麻烦。

从AST抽取
- 候选方案 -> AIDL files -> 一些接口在AIDL中定义 -> 失去大范围C++直接实现的接口 -> 将AIDL文件转化为C++文件 -> AIDL工具可以不丢失任何信息将AIDL文件定义的接口转化为C++实现  将C++实现转为AIDL文件可呢个降低接口模型的精确度

- 从IR中抽取 -> IRs -> 会优化一些信息，例如类型别名，使得提取精确的接口信息变得更加困难

- 从AST中抽取 
  - 变量名称和变量类型原封不动 
  - 记录每个类型转换表达式  
  - 编译器解析所有头文件的依赖性，并在 AST 中以正确的顺序提供类型，我们可以顺序处理 AST 来解析 typedef 类型的原始类型  
  - 清晰的看出 onTransact dispatcher 中每个接口的所有事务代码框架 
  - AST中语句分离

**事务代码识别**
根据事务代码，目标接口的 onTransact 函数将调度控制流到目标事务
调度过程通常作为 C++ 代码中的 switch 语句实现，并转化成 AST 中的多 case 节点（每个 case 表示一个被调用的事务）
通过分析 AST 中的 case 节点识别所有事务，识别出关联的常量事务代码

**输入输出变量抽取**
事务中三种可能的变量类：
1. 顺序变量 没有任何先决条件
2. 条件变量 取决于一些条件 条件不满足：NULL或不存在或与满足时不同的类型
3. 循环变量 在循环甚至嵌套循环中反序列化

这三种类型的变量恰好与程序中的三种类型的语句相对应，即顺序语句，条件语句和循环语句。
因此，我们将主要在AST中处理这些类型的语句。 
此外，我们还将考虑return语句。 

由于 onTransact 函数以类似方式处理输入和输出，因此我们仅使用输入变量演示细节。
- 顺序语句
![](截屏2020-08-04%20下午12.57.03.png)
  - checkInterface：在事务开始时检查由客户提供的接口 token 不匹配仅返回，不能填充任意字节到数据包中
  - readXXX：变量名-> semantics 选择语义更丰富的类型作为变量类型（将此策略应用于类型转换表达式）
  - read(a, sizeof(a)*num)：服务器将直接从数据包中复制原始结构或阵列
  - read(a)：服务器将读取 Flattenable 或 Light Flattenable 结构
  - readFromParcel：反序列化过程发生在实现 Parcelable 接口的另一个类或结构中
  - callLocal：变量类型不是指针，则视为输入变量，否则视为输出变量
  - Misc Function：对于特殊的输入格式，数据包将被传递到一个函数中 将此输入标记为一个函数并递归处理数据 收集包含相应功能的文件
- 条件语句
![](截屏2020-08-04%20下午12.57.14.png)
    条件语句有几种类型，比如 if 和 switch
    在实例中，Line 4 是否执行取决于 isFDvalid 变量，我们把 fd 视作条件输入，并且会记录对于 fd 的条件来获得更精确的接口模型
- 循环语句
![](截屏2020-08-04%20下午12.57.23.png)
    循环语句有几种表现形式，for 和 while
    在实例中，我们记录 key 被读取的次数，即 size。我们将 key, fd, value 视为循环变量
    可能有一种for语句 for（auto i：vector），没有明确的周期数，试探性地猜测周期计数是语句之前从包裹读取的先前值
- 返回语句
![](截屏2020-08-04%20下午1.04.47.png)
    一个事务中可能会出现多个返回语句，指向不同的执行路径
    如果路径返回错误代码，则表示该路径不太可能存在漏洞 -> 将为该路径分配较低的概率，这意味着将减少采用该路径的测试用例
    帮助我们生成显式的事务间依赖关系，因为不满足依赖关系的输入通常会退回到错误处理路径

**类型定义抽取**
类型定义抽取可以丰富变量语义以生成更好的输入
主要分析三种类型：
- 类结构定义：包括联合和结构。从 AST 中提取此类对象的成员。
- 枚举定义：提取所有给定的（恒定）枚举值。
- 类型别名：AOSP 中存在很多 typedef 语句。
    示例中，pid_t 其实是 int 类型，就可以使用随机整数生成 pid_t 类型的变量
![](截屏2020-08-04%20下午1.13.43.png)

AOSP是一个整体项目，需要将命名空间添加到变量类型中，以免在提取此类类型知识时发生冲突。
由编译器保证，C/C++ 文件使用的所有标头将按顺序包含在 AST 中
我们可以收集所有相关类型的定义。

#### Chapter 3.5 依赖关系推断器
**接口依赖关系**
多层接口如何识别和产生  一个接口是如何被其他接口使用的
- Generation 依赖
如果一个接口通过另外一个接口获取，称之为 generation 依赖
示例：
我们可以直接从服务管理器获得安卓原生系统服务接口，即顶层接口
对于多层接口而言，高层接口通过调用 writeStrongBinder 将深层接口序列化为 reply
- Use 依赖
如果一个接口被另外一个接口所使用，称之为 use 依赖
示例：
接口 A 被接口 B 使用
接口 B 会调用 readStrongBinder 从数据包中反序列化 A

**变量依赖关系**
事务中变量之间存在依赖关系 变量对是否在同一事务中，分为事务内依赖和事务间依赖
- 事务内依赖关系
变量取决于事务内另一个变量，事务中的变量之间可能存在条件依赖，循环依赖和数组大小依赖。
条件依赖：一个变量的值决定另外一个变量是否存在
循环依赖：一个变量决定另外一个变量读写的次数
数组大小依赖：数组变量的大小由另一个变量指定
- 事务间依赖关系
变量取决于不同事务中的另外一个变量， 即一个事务的输入通过另外一个事务的输出来获取
提出算法来处理这种依赖
![](截屏2020-08-04%20下午1.35.25.png)
按照以下原则提取事务间依赖关系：
  1. 一个变量是输入，另一个变量是输出
  2. 这两个变量位于不同的事务中
  3. 输入变量的类型等于输出变量的类型
  4. 输入变量类型很复杂（不是原始类型），或者输入变量名称和输出变量名称相似，相似度测量算法可以定制。

#### Chapter 3.6 Fuzzer 引擎
1. Fuzzer 管理器将 Fuzzer 二进制文件，接口模型和依赖关系同步到手机，并在手机上启动 Fuzzer
2. Fuzzer 生成测试用例，即一个事务及相关的接口，来 Fuzz 远程代码
3. Fuzzer 管理器将从手机周期性同步 crash 日志

Fuzz 安卓原生系统服务 -> fuzz 事务代码指定的事务
随机生成事务 -> 调用相应的接口

**事务生成器**
基于接口模型不断生成事务的输入变量
principles：
- 约束：如果一个变量被另外一个变量约束，在生成变量前检查约束
- 依赖关系：如果一个变量可以被其他事务所生成，则应使用它们以高概率生成它。先生成相关事务，然后从相关的reply包中获取输出
- 类型和名称：无论上述依赖关系是否存在，我们都可以依据类型和名称生成变量

**接口获取**
顶层接口：通过服务管理器获取它们。 
多层接口：通过接口依赖关系递归获得

### Chapter 4 实现
使用scratch实现了FANS的原型
<!--
1. 将AFL移植到Android需要大量的工程工作。 
2. 基于AFL的模糊测试器可以有效地测试一个独立的程序或服务，因此必须逐一编译和测试每个目标服务，这是不可扩展的
3. AFL在测试基于服务的应用程序（包括基于binder IPC的服务）方面并不有效
-->

statistics of implementation
![](截屏2020-08-04%20下午2.49.05.png)

**接口收集器**
1. 编译 AOSP 代码库，并记录编译命令
2. 在扫描第3.3节和第3.4.4节指出的特征时浏览这些命令，使用 Python 可以轻松实现这一步骤

**接口模型抽取**
1. 将编译命令转换为 cc1 命令，同时链接到用于遍历AST并提取粗略接口模型的Clang插件
2. 在 AST 上做一个近似切片，仅保留与输入和输出变量相关的语句
3. 对粗糙模型进行后处理，以便模糊器引擎可以轻松使用它。接口模型以JSON格式存储

**依赖关系推断器**
依据用 JSON 描述的接口模型，dependency inferer 遍历该模型并进行接口依赖关系推断
dependency inferer 还根据算法1获得事务间的依赖关系

**Fuzzer 引擎**
实现简单的Fuuzer 管理器以便在多个手机运行 Fuzzer 并在主机和手机之间同步数据
在启用 ASan 的情况下构建了整个AOSP
Fuzzer 作为原生可执行文件使用 C++ 实现
某些安卓原生系统服务在接受 RPC 请求时会检测调用者的权限，Fuzzer 以 root 权限执行
加速执行，总是通过在不需要 reply 的输出时将 transact 的 flag 参数置 1 来进行异步 RPC
当需要输出作为 reply 时，例如依赖关系推断，我们进行同步调用
为了分析触发的 crash ，使用安卓内置的 logcat 工具进行记录，并在 /data/tombstones/ 中记录本地崩溃日志

### Chapter 5 评估
> 实验设置
> 系统：Ubuntu 18.04 
> 配置：i9-9900k    32GB   2.5T SSD
> 测试设备：Pixel 1     Pixel 2XL 4     Pixel 3XL 1
> AOSP：PQ3A.190801.002     android-9.0.0_r46
以下结果来自 Pixel 2XL
#### 接口数据和依赖关系
**接口数据**
<!--
编译 1 h
发现源代码中的接口 几秒
-->
Interface Statistics
![](截屏2020-08-04%20下午3.15.51.png)
**接口依赖**
<!--
推断依赖关系  几秒
-->
Part of the Interface Dependency Graph
![](截屏2020-08-04%20下午3.20.55.png)

#### 抽取接口模型
<!--
抽取粗略接口模型 1 h
后处理 几秒
推断变量依赖关系 几秒
-->
**抽取接口模型数据**
- 事务
![](截屏2020-08-04%20下午3.30.44.png)
- 变量
仅计数直接在onTransact的变量
![](截屏2020-08-04%20下午3.33.00.png)
  - 变量模式
    变量分成三类：顺序，条件，循环
    简单的顺序语句中几乎没有变量，而在顺序语句中处理的大多数变量都具有String类型，因为几乎所有的接口在事务开始检查接口token，换句话说，几乎所有变量都是条件变量，因此必须提取对变量施加的约束以生成有效输入
    约束提取对于解决事务内依赖关系也是必需的
    几乎所有变量类型都可能在循环中发生。
  - 类型别名
    所有的别名为三种类型：基本类型，枚举类型，类结构类型
  - 变量依赖
    考虑事务间依赖，关注于输入依赖，根据数组项的类型生成数组依赖项
    几乎所有变量类型之间都存在依赖关系，尤其是基本类型和字符串类型
    此外，可以基于依赖关系生成类结构和绑定程序类型的变量，这有助于生成更多语义和结构良好的输入，从而对Android原生系统服务有更深程度的Fuzz

**抽取接口模型的完整性和精确度**
随机选择10个接口手动检查
成功恢复了所有事务代码，实现了完整性
几乎所有变量模式，变量名称和变量类型也都可以恢复。
模型并不完全精确，但足够好

#### 漏洞发现
测试设备：6台手机
测试时间：30dyas
<!--无法精确运行时间
1. fuzzer可能运行几分钟就崩溃
2. 在真实机器上，一旦安卓设备崩溃，只能重新刷机
-->
![](截屏2020-08-04%20下午3.57.09.png)
证明FANS生成的输入可以可以在复杂的约束下将控制流驱动到更深的路径中。

触发了138个Java异常：
Java应用程序有时依赖于Android原生系统服务 
一些本地服务还调用Java方法

**与现有研究对比**
![](截屏2020-08-04%20下午5.27.19.png)

#### case studies
**new_capacity overflow Inside read-Vector of IDrm**
漏洞类型：new_capaticy overflow
漏洞来源：IDrm - 通过IMediaDrmService获取的二级接口
漏洞函数：BnDrm::readVector
漏洞原因：
该函数调用 insertAt 分配一片缓冲区，缓冲区大小由数据中的变量size决定。在 insertAt 内部，对插入索引进行了完整性检查，如果索引错误，它将返回BAD_INDEX。但是不检查size参数。
漏洞触发：
根据接口依赖关系图，FANS可以自动生成IDrm接口。对于变量名的大小，FANS会生成一些危险值，例如-1，这很容易触发漏洞。我们可以通过这种漏洞进一步实现DoS攻击，从而防止其他应用使用必要的服务
漏洞缓解措施：
Parcel提供了安全实施的反序列化功能，可以执行输入验证。用Parcel::readByteVector替换readVector可以很好地修复漏洞。

**Out-of-bound Access Inside informAllUidData of statsd**
漏洞类型：Out-of-bound Access
漏洞来源：statsd - daemon in android 9
漏洞原因：
在事务 Call::INFORMALLUIDDATA 中，statsd 从数据包中反序列化三个向量，分别包含 int32_t，int64_t 和 ::android::String16 的项。这些向量将传递到 notifyAllUidData 中，然后转发到 UidMap 的 updateMap 方法。 函数 updateMap 循环循环访问三个向量。三个向量中的向量 uid 的大小用作循环计数。由于任何一个向量中的项目都应该与其他两个向量中的项目具有一一对应关系，因此这三个向量的长度应相同，以便迭代可以正常进行。 但是这个要求未经检查。
漏洞触发：
通过传入比其他两个更长的 uid 向量来实现越界访问。为了生成畸形的事务，FANS 首先从 AST 识别这三个输入的变量类型。 然后，它一一生成这些向量（1）生成向量大小（2）生成相应数量和类型的元素。 
Thinking：
相同的索引用于不同的向量，从而导致OOB漏洞。 
此错误是由输入验证失败引起的。这是一个更有趣的错误，如果使用得当，希望它可以产生除 DoS 之外的其他利用

**Stack Overflow Inside ip(6)tables-restore**
漏洞类型：Stack Overflow
漏洞来源：ip(tabels-restore)
漏洞函数：add_param_to_argv
漏洞发现：
Fuzz netd 守护程序（接口文件会自动生成）时。使用在事务 Call::WAKEUPADDINTERFACE 中引用的足够长的字符串编写 in_ifName ，然后调用wakeupAddInterface。 最后，它会在 add_param_to_argv 函数中触发堆栈溢出漏洞。
![](截屏2020-08-04%20下午4.48.35.png)
漏洞触发：
由于通过 readUtf8FromUtf16 从数据包中对字符串进行了反序列化（执行许多检查），仍然需要谨慎处理in_ifName。 在提取接口模型时，FANS 将 utf8 = true 标记为 in_ifName。 之后，FANS 使用相应的序列化方法 writeUtf8AsUtf16 将 in_ifName 序列化为数据，该数据可以通过完整性检查。 
Thinking：
该漏洞跨越三个过程：攻击者进程，netd和ip(6)tables-restore。 换句话说，此错误已深埋。 
尽管主要专注于 Fuzz Android原生系统服务，但发现 Linux 组件中存在漏洞。这表明Android系统服务与基本Linux组件之间存在密切的关系。鉴于此，可以断言还有另一种 Fuzz Linux组件的方法。
这两个错误也存在于 iptable 软件包中，可以在常规 Linux 发行版中找到

### Chapter 6 讨论
- 接口模型并不完美，但是对其改进并不容易
- 由于开发人员的行为，获取的依赖关系可能是不完整的

- Guided with coverage，FANS 可以发现更多漏洞
- 系统服务是状态敏感的，其覆盖范围可能会受到先前生成的输入或其他应用程序的调用的影响，将 coverage 整合到 FANS 中会是一个挑战

- 以 root 权限执行 Fuzz ，使得启动 Fuuzer 10分钟后也可以进入恢复模式，导致在实验过程中需要手动刷机，大大影响了 FANS 的效率。要解决这个问题，要么限制 Fuzzer 的权限，要么寻找自动刷机的方法
- Android 9 中存在三种服务，位于不同的域内。这三种服务共享相同的体系结构。可以轻松的将本文的方法转移到其他域内。对于一些类似的接口，即定制的接口，他们由应用程序实现和实例化，并由客户端传递到服务端，依旧可以使用本文提出的方法 Fuzz 这些实现，但是需要手动实例化这些接口


由于编译过程中 AIDL 会动态生成接口
接口收集器 ->
顶层接口 

实现 -> collector.py 将编译命令过滤后生成 接口文件 -> 通过